>>>>>>>>>> 1187553073
マルチサイトの登録手続き
	0. 親/子関係を結ぶ各サイトが存在する。
	   親は一つのサイトのみなれる。
	   ※複数が親として機能する方式もありうるが、ここでは検討対象としない。
	1. 親となるサイト上で設定を行い、マルチサイトの親とする。
	2. 子サイト上で設定を行い、親サイトの位置を教える。
		→子サイトが親サイトに登録を要求する。
		  成功するまで繰り返し。
	3. 子の登録時に親は子の構成情報を取得する。
		※DB に置かずに毎回取得してもよい?
		- 仮想クラスタの外部 IP アドレス
		- ホストノードの
		  メモリサイズ、ローカルストレージサイズ、ネットワークI/F
		- iSCSI あり/なし。ありの場合、IQN、サイズ。
	4. 親サイト上で、以下を行う。
	   - 子サイトの構成情報の確認。
	   - 子サイトの有効/無効の設定。
	   - 子サイトの優先順位の設定。

マルチサイトの登録削除手続き
	親サイト側で子サイトを無効に設定する。
	  条件: 当該サイト上で稼働中の仮想クラスタが存在しないこと

マルチサイト予約
	仮想クラスタ予約の指定に以下を追加する。
	- 単一サイト指定 (親サイトのみに限定)
	- 複数サイト指定 (仮想 frontend は親サイトに、残りは不定)
	※ 仮想 frontend が親サイト以外にある場合については検討対象としない。

仮想クラスタ起動
シングルサイトを前提とした起動では、以下の手続きとなっている。
	1. 仮想 frontend ノード起動
	  1.1 RestoreRoll 生成
	  1.2 lightsout
	  1.3 全ノードの iSCSI ボリューム生成
	  1.4 全ノードの VMX ファイル生成
	  1.5 frontend ノード起動/インストール
	2. 仮想 compute ノード起動
	  2.1 frontend ノードのインストール完了を待つ。
	  2.2 compute ノード起動/インストール
これを以下のように変更する。
	0. セットアップ (仮想クラスタを構成する各サイトへ要求)
	  0.1 RestoreRoll 生成
	  0.2 lightsout
	  0.3 全ノードの iSCSI ボリューム生成
	  0.4 全ノードの VMX ファイル生成
	1. 仮想 frontend ノード起動 (仮想 frontend が動作するサイトへ要求)
	  1.1 frontend ノード起動/インストール
	2. 仮想 compute ノード起動 (仮想 compute が動作するサイト群へ要求)
	  2.1 frontend ノードのインストール完了を待つ。
	  2.2 compute ノード起動/インストール
このために、以下の変更を加える。
- 状態遷移を細分化する。
STARTING/STARTING2 を以下に再分割する。
--STARTING_SETUP
--STARTING_FRONTEND
--STARTING_COMPUTE
- STARTIG_SETUP→STARTING_FRONTEND→STARTING_COMPUTE→RUNNING の遷移のみでなく、親サイトの指定によって任意の遷移を可能とする。

DB テーブル
 ※サイトの構成情報は定期的に取得/更新を行う。
	サイト情報 (新規)
		id	: ID
		name	: 表示用の名前
		address	: 子サイトのアドレス
		mode	: 有効/無効
		priority: 優先度
	ノード情報 (新規; クラスタ DB のサブセット)
		ID	: ID
		Site	: 所属サイト ID
		Appliance: 所属 ホスト側Appliance
		Name	: 名前
	メモリ情報 (既存)
	ローカルストレージ情報 (既存)
	ホスト側Appliance情報 (既存)

	iSCSI情報 (既存; site 情報を追加する)
		id	: ID
		start	: 開始時刻
		end	: 終了時刻
		site	: 所属サイト ID
		address	: アドレス
		port	: ポート番号
		volgroup: ボリュームグループ
		size	: サイズ
		serverkey: 認証情報
その他
- エラーログを DB に格納し、親サイト上からエラー内容の確認ができるようにする。
>>>>>>>>>> 1187553351
マルチサイトの登録手続き
	0. 親/子関係を結ぶ各サイトが存在する。
	   親は一つのサイトのみなれる。
	   ※複数が親として機能する方式もありうるが、ここでは検討対象としない。
	1. 親となるサイト上で設定を行い、マルチサイトの親とする。
	2. 子サイト上で設定を行い、親サイトの位置を教える。
		→子サイトが親サイトに登録を要求する。
		  成功するまで繰り返し。
	3. 子の登録時に親は子の構成情報を取得する。
		※DB に置かずに毎回取得してもよい?
		- 仮想クラスタの外部 IP アドレス
		- ホストノードの
		  メモリサイズ、ローカルストレージサイズ、ネットワークI/F
		- iSCSI あり/なし。ありの場合、IQN、サイズ。
		※iSCSI ターゲットは親サイト上のみに限定してよいか?
	4. 親サイト上で、以下を行う。
	   - 子サイトの構成情報の確認。
	   - 子サイトの有効/無効の設定。
	   - 子サイトの優先順位の設定。

マルチサイトの登録削除手続き
	親サイト側で子サイトを無効に設定する。
	  条件: 当該サイト上で稼働中の仮想クラスタが存在しないこと

マルチサイト予約
	仮想クラスタ予約の指定に以下を追加する。
	- 単一サイト指定 (親サイトのみに限定)
	- 複数サイト指定 (仮想 frontend は親サイトに、残りは不定)
	※ 仮想 frontend が親サイト以外にある場合については検討対象としない。

仮想クラスタ起動
シングルサイトを前提とした起動では、以下の手続きとなっている。
	1. 仮想 frontend ノード起動
	  1.1 RestoreRoll 生成
	  1.2 lightsout
	  1.3 全ノードの iSCSI ボリューム生成
	  1.4 全ノードの VMX ファイル生成
	  1.5 frontend ノード起動/インストール
	2. 仮想 compute ノード起動
	  2.1 frontend ノードのインストール完了を待つ。
	  2.2 compute ノード起動/インストール
これを以下のように変更する。
	0. セットアップ (仮想クラスタを構成する各サイトへ要求)
	  0.1 RestoreRoll 生成
	  0.2 lightsout
	  0.3 全ノードの iSCSI ボリューム生成
	  0.4 ネットワーク設定(VLAN, VPN)
	  0.5 全ノードの VMX ファイル生成
	1. 仮想 frontend ノード起動 (仮想 frontend が動作するサイトへ要求)
	  1.1 frontend ノード起動/インストール
	2. 仮想 compute ノード起動 (仮想 compute が動作するサイト群へ要求)
	  2.1 frontend ノードのインストール完了を待つ。
	  2.2 compute ノード起動/インストール
このために、以下の変更を加える。
- 状態遷移を細分化する。
STARTING/STARTING2 を以下に再分割する。
--STARTING_SETUP
--STARTING_FRONTEND
--STARTING_COMPUTE
- STARTIG_SETUP→STARTING_FRONTEND→STARTING_COMPUTE→RUNNING の遷移のみでなく、親サイトの指定によって任意の遷移を可能とする。

DB テーブル
 ※サイトの構成情報は定期的に取得/更新を行う。
	サイト情報 (新規)
		id	: ID
		name	: 表示用の名前
		address	: 子サイトのアドレス
		mode	: 有効/無効
		priority: 優先度
	ノード情報 (新規; クラスタ DB のサブセット)
		ID	: ID
		Site	: 所属サイト ID
		Appliance: 所属 ホスト側Appliance
		Name	: 名前
	メモリ情報 (既存)
	ローカルストレージ情報 (既存)
	ホスト側Appliance情報 (既存)

	iSCSI情報 (既存; site 情報を追加する)
		id	: ID
		start	: 開始時刻
		end	: 終了時刻
		site	: 所属サイト ID
		address	: アドレス
		port	: ポート番号
		volgroup: ボリュームグループ
		size	: サイズ
		serverkey: 認証情報
その他
- エラーログを DB に格納し、親サイト上からエラー内容の確認ができるようにする。
- 仮想クラスタ起動の進捗情報を増やし、親サイト上から容易に確認できるようにする。
>>>>>>>>>> 1189702275
- 全体の構成

-- レジストリサーバ
-- 物理クラスタ群

 レジストリサーバは、物理クラスタの ID 管理を行う。
-- 登録
--- 物理クラスタの公開アドレスの登録(ID 発行)
-- 検索
--- ID に対応する物理クラスタ公開アドレスの取得
--- 物理クラスタ公開アドレスに対応する ID の取得
-- 一覧
--- 全ての物理クラスタ ID および公開アドレスの取得
(マジックナンバを基準位置として要求数のエントリを返す)

- 登録

登録手続きは 2 相コミットで行う。

 0. まず、登録受付クラスタはローカルノードのみ用いて登録を試みる。
    登録が可能ならローカルに仮想クラスタを登録して終了。
    失敗した場合は以下の処理を行う。
 1. 登録受付クラスタはレジストリサーバから他クラスタの情報の取得を行う。
	取得時にはマジックナンバ(インデックス情報/初期値 0)を与える。
	大量にクラスタが存在する場合にもレジストリサーバは要求された数の
	クラスタアドレスのみ返す。
	さらに情報が必要な場合は、マジックナンバを用いてその続きを取得する。
 2. 登録受付クラスタはレジストリサーバから取得した他のクラスタに
    ノード確保を要求する。
    確保できる限りのノードを確保して応答を返す。
    一つも確保可能なノードがなければ失敗を返す。
 3. 必要な数のノードが確保できるまで 1,2 を繰り返す。
 4. 必要な数のノードが確保できたら、ノード確保を行った
    他のクラスタ全てに確保完了を通知する。確保は確定される(DBはそのまま)。
    必要な数のノードが確保できなかった場合は、ノード確保を行った
    他のクラスタ全てに確保失敗を通知する。確保は取り消される(削除)。

 仮想ノードを起動する各クラスタ上に分散して以下の DB テーブルが作成される。
    登録受付(親)クラスタ:
        仮想クラスタ情報
	- (親での)仮想クラスタ ID
	- 開始時刻/終了時刻
	- 親クラスタアドレス (=0.0.0.0 : 自分自身)
	- 親クラスタ上での仮想クラスタ ID
	仮想クラスタノード情報のリスト (親/子すべての情報を持つ)
	- ノード ID
	- 仮想クラスタ ID
	- 子クラスタアドレス
	- 子クラスタ上での仮想クラスタ ID
	- 子クラスタ上での親ノード名
    その他の(子)クラスタ:
        仮想クラスタ情報
	- (子での)仮想クラスタ ID
	- 開始時刻/終了時刻
	- 親クラスタアドレス
	- 親クラスタ上での仮想クラスタ ID
	仮想クラスタノード情報のリスト (自クラスタの情報のみ持つ)
	- ノード ID
	- 仮想クラスタ ID
	- 子クラスタアドレス (=0.0.0.0 : 自分自身)
	- 子クラスタ上での仮想クラスタ ID
	- 子クラスタ上での親ノード名

 ※ IP アドレス空間は全ての仮想クラスタで同一のものを用いる。VLAN で識別。

- 起動/停止

  1. 登録受付クラスタ上で、登録時刻になったことを検出する。
  2. 登録受付クラスタから、vfrontend ホストを起動する。
	1) vfrontend が属するクラスタにモード変更を通知する。
	   (モードを stopped から starting_frontend に変更)
	2) モード変更を契機に、vfrontend が所属するクラスタは
	   vfrontend 起動処理を行う。
	   1. restore roll 生成
	   2. lightsout
	   3. iSCSI 領域の確保
	   4. VLAN 設定、VPN 設定
	   5. VMX 生成
	   6. VM 起動
  3. 登録受付クラスタは、vfrontend からの起動完了通知を待つ。
  4. 登録受付クラスタから、vcompute ホストを起動する。
	1) vcompute が属するクラスタにモード変更を通知する。
	   (モードを stopped から starting_compute に変更)
	2) モード変更を契機に、vcompute が所属する各クラスタは
	   vcompute 起動処理を行う。
	   1. VLAN 設定、VPN 設定
	   2. iSCSI 領域の確保
	   3. VMX 生成
	   4. VM 起動

シーケンス
  <<<起動処理>>>
  登録受付クラスタ         vfrontend 所属クラスタ
      |status=stopped              |status=stopped
      |                            |
 (時刻検出)                        |
      |status=starting_frontend    |
      |--------------------------->|status=starting_frontend
      |                            |
      |                        restore roll
      |                        lightsout
      |< - - - 失敗            iSCSI 領域
      |                        VLAN/VPN
      |                        VMX 生成
      |                        VM 起動
      |<--------成功---------------|
      |                            |status=running
      |<--------起動完了-----------|
      |status=starting_compute               vcompute 所属クラスタ
      |--------------------------------------------->|status=starting_compute
      |                                              |
      |< - - - 失敗                               iSCSI 領域
      |                                           VLAN/VPN
      |                                           VMX 生成
      |                                           VM 起動
      |                                              |status=running
      |<--------------------成功---------------------|
      |status=running

 <<<停止処理>>>
      :
      |                            :                 :
 (時刻検出)                    (時刻検出)         (時刻検出)
      |status=stopping             |status=stopping  |status=stopping
      |                          VM 停止             |
      |                            |status=stopped   |
      |<------成功-----------------|               VM 停止
      |                                              |status=stopped
      |<--------------------成功---------------------|
      |status=stopped

プロトコル
- vfrontend/vcompute の起動/起動

	<ChangeVnodeStatusReq cluster="1" vnode="1"
	 status="starting_vfrontend" />

- 仮想ノード状態通知
	<NotifyVnodeStatus cluster="1" vnode="1" status="started">
	 Starting vfrontend succeeded
	</NotifyVnodeStatus>
>>>>>>>>>> 1190648450
- 全体の構成

-- レジストリサーバ
-- 物理クラスタ群

 レジストリサーバは、物理クラスタの ID 管理を行う。
-- 登録
--- 物理クラスタの公開アドレスの登録(ID 発行)
--- MAC アドレス空間の発行
-- 検索
--- ID に対応する物理クラスタ公開アドレスの取得
--- 物理クラスタ公開アドレスに対応する ID の取得
-- 一覧
--- 全ての物理クラスタ ID および公開アドレスの取得
(マジックナンバを基準位置として要求数のエントリを返す)

- 登録

登録手続きは 2 相コミットで行う。

 0. まず、登録受付クラスタはローカルノードのみ用いて登録を試みる。
    登録が可能ならローカルに仮想クラスタを登録して終了。
    失敗した場合は以下の処理を行う。
 1. 登録受付クラスタは既知の他クラスタに対して以下を行う。
    既知の他クラスタがないあるいは更に他クラスタ資源が必要と判断した場合は、レジストリサーバに最新情報の問合せを行う。
 2. 登録受付クラスタは他のクラスタにノード確保を要求する。
    確保できる限りのノードを確保して応答を返す。
    一つも確保可能なノードがなければ失敗を返す。
 3. 必要な数のノードが確保できるまで 1,2 を繰り返す。
 4. 必要な数のノードが確保できたら、ノード確保を行った
    他のクラスタ全てに確保完了を通知する。確保は確定される(DBはそのまま)。
    必要な数のノードが確保できなかった場合は、ノード確保を行った
    他のクラスタ全てに確保失敗を通知する。確保は取り消される(削除)。

 仮想ノードを起動する各クラスタ上に分散して以下の DB テーブルが作成される。
    登録受付(親)クラスタ:
        仮想クラスタ情報
	- (親での)仮想クラスタ ID
	- 開始時刻/終了時刻
	- 親クラスタアドレス (=0.0.0.0 : 自分自身)
	- 親クラスタ上での仮想クラスタ ID
	仮想クラスタノード情報のリスト (親/子すべての情報を持つ)
	- ノード ID
	- 仮想クラスタ ID
	- 子クラスタアドレス
	- 子クラスタ上での仮想クラスタ ID
	- 子クラスタ上での親ノード名
    その他の(子)クラスタ:
        仮想クラスタ情報
	- (子での)仮想クラスタ ID
	- 開始時刻/終了時刻
	- 親クラスタアドレス
	- 親クラスタ上での仮想クラスタ ID
	仮想クラスタノード情報のリスト (自クラスタの情報のみ持つ)
	- ノード ID
	- 仮想クラスタ ID
	- 子クラスタアドレス (=0.0.0.0 : 自分自身)
	- 子クラスタ上での仮想クラスタ ID
	- 子クラスタ上での親ノード名

 ※ IP アドレス空間は全ての仮想クラスタで同一のものを用いる。VLAN で識別。

- 起動/停止

  1. 登録受付クラスタ上で、登録時刻になったことを検出する。
  2. 登録受付クラスタから、vfrontend ホストを起動する。
	1) vfrontend が属するクラスタにモード変更を通知する。
	   (モードを stopped から starting_frontend に変更)
	2) モード変更を契機に、vfrontend が所属するクラスタは
	   vfrontend 起動処理を行う。
	   1. restore roll 生成
	   2. lightsout
	   3. iSCSI 領域の確保
	   4. VLAN 設定、VPN 設定
	   5. VMX 生成
	   6. VM 起動
  3. 登録受付クラスタは、vfrontend からの起動完了通知を待つ。
  4. 登録受付クラスタから、vcompute ホストを起動する。
	1) vcompute が属するクラスタにモード変更を通知する。
	   (モードを stopped から starting_compute に変更)
	2) モード変更を契機に、vcompute が所属する各クラスタは
	   vcompute 起動処理を行う。
	   1. VLAN 設定、VPN 設定
	   2. iSCSI 領域の確保
	   3. VMX 生成
	   4. VM 起動

シーケンス
  添付資料参照

cron 処理
- 1 分毎に cron で VC の監視プロセスを起動する。
- VC 監視プロセスはイベント発生を監視し、イベント処理がなければ 1 分未満に修了する。ここでのイベント処理とは以下を指す。
-- 予定時刻での仮想クラスタ起動/停止
-- 仮想クラスタ/仮想ノードの状態遷移およびそれに伴う処理
- VC 監視プロセスは、イベント処理中などの理由で複数動作している可能性がある。
   複数プロセスが同時に動作していても問題を起こさないようにする。
-- DB アクセスはトランザクション処理なので問題ない。
-- 仮想クラスタ/仮想ノード状態の変更は、状態遷移で競合を防ぐ。



プロトコル
- vfrontend/vcompute の起動/起動

	<ChangeVnodeStatusReq cluster="1" vnode="1"
	 status="starting_vfrontend" />

- 仮想ノード状態通知
	<NotifyVnodeStatus cluster="1" vnode="1" status="started">
	 Starting vfrontend succeeded
	</NotifyVnodeStatus>


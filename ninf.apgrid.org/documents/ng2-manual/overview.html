<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=us-ascii">
<title>Overview</title>
</head>

<body bgcolor=white>

<h2><a name="Overview">1 Overview</a></h2>

<h3><a name="GridRPC">1.1 GridRPC</a></h3>

<p>Ninf-G uses the Globus Toolkit to provide a running
environment for GridRPC.</p>

<p>GridRPC is middleware that provides a model for access to
remote libraries and parallel programming for tasks on a grid.
Typical GridRPC middleware includes Ninf and Netsolve.</p>

<p>GridRPC is considered effective for use in the following
cases.</p>

<ul>
<li>
<p>Commercial programs or libraries that use resources which are
on particular computers on the grid are sometimes provided only
in binary format and cannot be executed on particular computers.
There are also problems concerning licensing and
source code compatibility.
Furthermore, when using resources that can only be used with
particular machines, such as video cameras, electron microscopes,
telescopes and sensors, processing for the use of those resources
on those machines is necessary.</p>

<p>In such cases, an environment that allows the resources
(including software) to be used on a particular computer is needed.</p>

<li>
<p>When there are many programs that execute routines that
do a large amount of computation on broadband servers on the grid,
it takes much time just to run parts of the program.</p>

<p>The time required to run the program can be shortened by
off-loading such parts to a broadband server.</p>

<p>In cases when there are strong demands on memory and disk space
on the client machine so that broadband computation cannot be done,
it is desirable to be able to do easily understood offloading
with no consideration given to argument marshalling.</p>

<li>
<p>Execution of Parameter Sweep by multiple servers on the grid</p>

<p>Parameter Sweep is execution of computation on multiple servers
in parallel using some subset of the parameters.
The respective servers run independently using different
parameters, with virtually no dependence on other servers.</p>

<p>There are surprisingly many programs like Parameter Sweep.</p>

<p>The Monte Carlo method is one of them.</p>

<p>Although Parameter Sweep can also be implemented
with a Message Passing Interface (MPI),
programming is rather simple with GridRPC and
it can be executed to match the (dynamically changing) scale
of the grid (execution by multiple clusters, taking resource
management, security, etc. into account).</p>

<li><p>Ordinary or large-scale task parallel programs on a grid</p>

<p>Task arrangement programs are easy to write with GridRPC.
An API that supports the synchronization of various
task arrangements with mixed exchange among multiple clients
and servers can be used.</p>

<p>GridRPC not only provides an interface for easy mathematical
computation and scheduling of tasks for parallel execution,
but the execution of processing that matches the (dynamically changing)
scale of the grid is possible, as in the case of Parameter Sweep.</p>
</ul>


<h3><a name="Overview_of_Ninf-G">1.2 Overview of Ninf-G</a></h3>

<p>Ninf-G is a set of library functions that provide an RPC
capability in a Grid environment based on theGridRPC API
specifications.</p>

<h4><a name="Clients_and_servers">1.2.1 Clients and servers</a></h4>

<p>Ninf-G and the application programs that use Ninf-G consist
of Ninf-G Executables that execute computation on
server machines and Ninf-G Clients that issue requests
for computation to the Ninf-G Executables from client machines.</p>

<p>The Ninf-G Executables consist of functions that perform
calculations (calculation functions) and a Ninf-G stub program that
calls the calculation functions.
Communication between clients and servers is
accomplished by TCP/IP using a proprietary Ninf-G protocol.</p>

<p>The relationships between clients and servers is
illustrated in Fig. 1.</p>

<center>
<img src="figure/composition-ClientServer.jpeg"
    alt="composition-ClientServer.jpeg">
<p>Figure 1: Clients and servers</p>
</center>

<h4><a name="Program_hierarchy">1.2.2 Program hierarchy</a></h4>

<p>Ninf-G employs the capabilities provided by the Globus Toolkit
(<a href="http://www.globus.org/">http://www.globus.org/</a>)
for server machine authentication, information search,
job start-up, communication and file transfer.
The relations among applications, the Ninf-G, Globus Toolkit
and the OS are illustrated in Fig. 2.</p>

<center>
<img src="figure/composition-ProgramHierarchy.jpeg"
    alt="composition-ProgramHierarchy.jpeg">
<p>Figure 2: Program hierarchy</p>
</center>

<p>Ninf-G Clients comprise the following elements.</p>

<dl>
<dt> Applications
<dd> Programs written by Ninf-G users

<dt> Ninf-G Client Library
<dd> The set of API functions provided by Ninf-G for Ninf-G Clients

<dt> Globus Toolkit
<dd> The set of functions provided by the Globus Toolkit
</dl>

<p>Ninf-G Executables comprise the following elements.</p>

<dl>
<dt> Computation functions
<dd> Programs written by Ninf-G users

<dt> Ninf-G stub
<dd> A stub program produced by the Ninf-G stub generator

<dt> Ninf-G Executable Library
<dd> The set of API functions provided by Ninf-G for Ninf-G Executables

<dt> Globus Toolkit
<dd> The set of functions provided by the Globus Toolkit
</dl>


<h4><a name="Operating_conditions">1.2.3 Operating conditions</a></h4>

<p>Ninf-G is supplied to the user as a source package, which
includes the library functions (API) and utility commands.
The operating conditions for the library functions and
utility commands are shown in Table 1.</p>

<center>
<table border>
<caption align="top"> Table1: Operating conditions</caption>
<tr>
<td><b>Globus Toolkit</b></td>
<td>2.2 or later</td>
</tr>

<tr><td>-</td><td>-</td></tr>
<tr>
<td><b>Target machine</b></td>
<td>SPARC</td>
</tr>
<tr>
<td><b>Operating system</b></td>
<td>Solaris 5.9</td>
</tr>
<tr>
<td><b>Compiler</b></td>
<td>Sun Compiler or gcc-2.95</td>
</tr>
<tr>
<td><b>Globus Toolkit Flavor</b></td>
<td>vendorcc32dbg, vendorcc32dbgpthr, gcc32dbg, gcc32dbgpthr</td>
</tr>

<tr><td>-</td><td>-</td></tr>
<tr>
<td><b>Target machine</b></td>
<td>PC-AT compatible (x86, IA64, Opteron)</td>
</tr>
<tr>
<td><b>Operating system</b></td>
<td>Linux(*1)</td>
</tr>
<tr>
<td><b>Compiler</b></td>
<td>gcc-2.95, gcc-3.x(*2)</td>
</tr>
<tr>
<td><b>Globus Toolkit Flavor</b></td>
<td>gcc32dbg, gcc32dbgpthr, gcc64dbg, gcc64dbgpthr</td>
</tr>

<tr><td>-</td><td>-</td></tr>
<tr>
<td><b>Target machine</b></td>
<td>SGI Origin 2000 (MIPS)</td>
</tr>
<tr>
<td><b>Operating system</b></td>
<td>IRIX64 6.5</td>
</tr>
<tr>
<td><b>Compiler</b></td>
<td>SGI Compiler</td>
</tr>
<tr>
<td><b>Globus Toolkit Flavor</b></td>
<td>vendorcc64dbg or vendorcc64dbgpthr</td>
</tr>

<tr><td>-</td><td>-</td></tr>
<tr>
<td><b>Target machine</b></td>
<td>HP Alpha</td>
</tr>
<tr>
<td><b>Operating system</b></td>
<td>Tru64 UNIX(OSF1 V5.1)</td>
</tr>
<tr>
<td><b>Compiler</b></td>
<td>Compaq C or gcc 3.x</td>
</tr>
<tr>
<td><b> Globus Toolkit Flavor</b></td>
<td>vendorcc64dbg or gcc64dbg</td>
</tr>

<tr><td>-</td><td>-</td></tr>
<tr>
<td><b>Target machine</b></td>
<td>IBM Power4</td>
</tr>
<tr>
<td><b>Operating system</b></td>
<td>AIX 5.2</td>
</tr>
<tr>
<td><b>Compiler</b></td>
<td>gcc 2.9</td>
</tr>
<tr>
<td><b>Globus Toolkit Flavor</b></td>
<td>gcc32dbg</td>
</tr>
</table>
</center>

<p>(*1) We are checking operating by the following distributions.
<ul>
<li> RedHat 8.0
<li> SuSE 8.1
<li> RedHat Advanced Workstation 2.1 
</ul>
</p>

<p>(*2) There are problems with gcc-2.96,
so we recommend you to use gcc-2.95.x or gcc3.x.</p>


<h4><a name="Requirements_for_operation">
1.2.4 Requirements for operation</a></h4>

<p>Ninf-G allows the definition of a single computation function
(1) or multiple computation functions
(2) for a Ninf-G Executable running on a server machine.
The execution schemes for these are shown in Fig. 3.
In either case, it is possible to execute,
just one computation function at a time on the Ninf-G Executable.
To execute multiple computation functions at the same time,
it is necessary to run multiple Ninf-G Executables. This is
illustrated in Fig. 4.</p>

<p>In Ninf-G, the second scheme (2) is referred to as
"Ninf-G Executable objectification" and the calling
of the computation is referred to as a "method call".</p>

<center>
<img src="figure/overview-stub.jpeg" alt="overview-stub.jpeg">
<p>Figure 3: Overview of operation</p>
</center>

<center>
<img src="figure/overview-parallel.jpeg" alt="overview-parallel.jpeg">
<p>Figure 4: Parallel execution</p>
</center>

<p>Ninf-G provides handles for manipulating a Ninf-G Executable.
Different handles are used for two schemes, (1) and (2),
described above.
As shown in Table 2, two types of handles are provided,
function handles and object handles.</p>

<table border>
<caption align=top> Table 2: Handles</caption>
<tr>
<td>Function handle</td>
<td>Used for manipulation of a Ninf-G
Executable for which a single function is defined
</td>
</tr>
<tr>
<td>Object handle</td>
<td>Used for manipulation of a Ninf-G
  Executable for which a multiple functions are defined
</td>
</tr>
</table>

<h4><a name="Starting_up_a_Ninf-G_Executable">
1.2.5 Starting up a Ninf-G Executable </a></h4>

<p>Ninf-G Executables that run on server machines are started
up from Ninf-G clients, which run on client machines.
A Ninf-G Executable is started up by performing the following
procedure using the job control method provided by
the Globus Toolkit.</p>

<p>When running a Ninf-G Client program, however, there is no
particular need for the user to be aware of this mechanism.</p>

<ol>
<li>A start-up request is sent from a Ninf-G Client to the gatekeeper.
<li>The gatekeeper starts up the job manager.
<li>The job manager starts up the Ninf-G Executable.
</ol>

<p>This process is shown in Fig. 5.</p>

<center>
<img src="figure/overview-startingOfStub.jpeg"
    alt="overview-startingOfStub.jpeg">
<p>Figure 5: Starting up a Ninf-G Executable</p>
</center>


<h4> <a name="Registering_and_accessing_Ninf-G_Executable">
1.2.6 Registering and accessing Ninf-G Executable information </a></h4>

<p>Starting up a Ninf-G Executable requires
path information that specifies the location of
the Ninf-G Executable on that server machine.
Information on the functions that are called by
the Ninf-G Executable is also required.
That information is collectively referred to as
the Ninf-G Executable information.
Ninf-G provides the following methods of registering and
accessing Ninf-G Executable information.</p>

<p>When running a Ninf-G Client program, however, there is no
particular need for the user to be aware of this mechanism.</p>

<ul>
<li>A file that contains the Ninf-G Executable information
(an LDIF file) is placed on the client machine.
The Ninf-G Client program obtains the Ninf-G Executable information
from this LDIF file (Fig. 6). 

<center>
<img src="figure/overview-stubInformationLdif.jpeg"
    alt="overview-stubInformationLdif.jpeg">
<p>Figure 6: Local LDIF file</p>
</center>

<li>The path information is defined in the configuration file
for the Ninf-G Client on the client machine.
The Ninf-G Client program obtains the path information
from the configuration file and uses it to start up
the Ninf-G Executable on the server machine.
The function information is obtained from
the Ninf-G Executable when it is started up (Fig. 7).

<center>
<img src="figure/overview-stubInformationList.jpeg"
    alt="overview-stubInformationList.jpeg">
<p>Figure 7: Ninf-G Executable</p>
</center>

<li>The LDIF file is registered in the MDS(*) of the server machine.
The Ninf-G Client program obtains the Ninf-G Executable information
from the MDS (Fig. 8).
<p>(*) The information search function provided by the Globus Toolkit.</p>

<center>
<img src="figure/overview-stubInformationMDS.jpeg"
    alt="overview-stubInformationMDS.jpeg">
<p>Figure 8: MDS</p>
</center>

</ul>

<h3><a name="Definition_of_terms">1.3 Definition of terms</a></h3>

<dl>
<dt><b> Ninf-G Client </b>
<dd>
<p>This is a program written by a user for the purpose of
controlling the execution of computation.
It is obtained by linking a user-written application program to
the Ninf-G Client Library (and Globus Toolkit).</p>

<dt><b> Ninf-G Client Library </b>
<dd>
<p>The Ninf-G Client Library puts together the API used by
application programs that run on client machines
(Ninf-G Client API).</p>

<dt><b> Ninf-G Executable </b>
<dd>
<p>This is a program written for the execution of user requests
for computation to be performed on a remote computer.
It is obtained by linking a user-written computation function
to stub code and the Ninf-G Executable Library (and Globus Toolkit).
The stub code is produced by the stub generator according to the interface
specifications of the user-defined computation function. The interface
specifications are written in the Ninf-G IDL (Interface Description Language)
specified by Ninf-G.</p>

<dt><b> Ninf-G Executable Library </b>
<dd> <p>The Ninf-G Executable Library puts together the API
(Ninf-G Executable API) used by Ninf-G Executable.</p>

<dt><b> Client (machine) </b>
<dd>
<p>A machine that is running a Ninf-G Client.</p>

<dt><b> Server (machine) </b>
<dd>
<p>A machine that is running a Ninf-G Executable.</p>
<br>

<dt><b> Function handle </b>
<dd>
<p>
A function handle is a data whose type is grpc_function_handle_t.
The function handle represents a mapping from a function name to an
instance of that function on a particular server.
</p>

<dt><b> Object handle </b>
<dd>
<p>
A object handle is a data whose type is grpc_object_handle_t_np.  The
object handle represents a mapping from a class name to an instance of
that class on a particular server.  The instance is called Ninf-G
remote object which is able to contain multiple methods.
</p>

<dt><b> Remote function </b>
<dd>
<p>A computational function written by the user.
(It might be only a single computation function
for a Ninf-G Executable)</p>

<dt><b> Remote method </b>
<dd>
<p>A computational function written by the user.
(It might be multiple computation functions for a
Ninf-G Executable)</p>

<dt><b> Session </b>
<dd>
<p>A session extends from the time an RPC is made to
the time its execution is completed.</p>

<p>In Ninf-G, a session extends</p>
<ul>
<li> from the time grpc_call() is called
until the time it is completed (returns)
<li> from the time grpc_invoke() is called
until the time it is completed (returns)
<li> from the time grpc_call_async()is called
until the time grpc_wait*() is completed
<li>from the time grpc_invoke_async() is called
until the time grpc_wait*() is completed.
</ul>

<dt><b> GridRPC API </b>
<dd>
<p>This is the standard API that systems implementing
GridRPC should have.
Concerning the GridRPC C language API, standardization by
the GGF WG is proceeding.</p>

<dt><b> Ninf-G IDL </b>
<dd>
<p>IDL is the acronym for Interface Definition Language.
It is a language for writing interfaces for the remote functions
and remote methods defined by Ninf-G Executables.</p>

<dt><b> Module name </b>
<dd>
<p>This is the identifier for Ninf-G Executables.
The user may specify any character string in the Ninf-G IDL.</p>

</dl>

<h3><a name="Function_added_in_Ninf-G_v2">
1.4 Function added in Ninf-G v2</a></h3>

<ul>
<li>Objectifying Ninf-G Executables

<p>Previously, only one remote method could be defined for
one Ninf-G Executable, but it is now possible to implement
multiple remote methods.
Furthermore, a mechanism for preserving state has been added
to Ninf-G Executable, and it is now possible for multiple
remote methods to share variable values, etc.
within a Ninf-G Executable.</p>

<li>Configuration file format that allows more detailed settings

<p>The settings and the description format are completely
new and allow more detailed settings.
Also, considering execution that makes use of multiple servers,
the format allows for the description of information on
multiple servers.</p>

<li>A function for acquiring information on
Ninf-G Executables that does not use MDS

<p>This function can obtain information on a Ninf-G Executable
without querying the MDS by either saving a file on
the client machine that contains information on the Ninf-G
Executable to be run and reading that file, or by using
the path information to start up the Ninf-G Executable on the
server and obtaining the information from the Ninf-G Executable.</p>

<li>A function for creating multiple handles with a single call to GRAM

<p>A function for creating multiple handles by calling GRAM
just one time is provided.
(The cost of calling GRAM is high, so reducing the number of
times it is called should reduce start-up time.)</p>

<li>Staging Ninf-G Executables

<p>A function for preserving the execution form of
a Ninf-G Executable on a client machine, transferring
that format to the server when GRAM is called,
and running the executable is provided.</p>

<li>Callback

<p>A function for executing a function on a Ninf-G Client
from a Ninf-G Executable is provided.
The status of the Ninf-G Executable on the Ninf-G Client can be
obtained and the states of variables can be input and output.</p>

<li>Canceling a session

<p>A session can be terminated in progress by requesting
cancellation of the session.
(Ninf-G v1 only provides a means of killing a Ninf-G Executable
with a signal to stop processing;
it is not possible to end a session.)</p>

<li>Heart-beat for notifying of the execution status of a Ninf-G Executable

<p>Ninf-G Executables send a heart-beat signal to
Ninf-G Clients at fixed time intervals, thus making
it possible for clients to detect when execution is halted
for any reason.</p>
</ul>

<h3> <a name="Compatibility_with_Ninf-G_v1">
1.5 Compatibility with Ninf-G v1</a></h3>

<ul>
<li>Source code compatibility

<p>The versions are source code compatible.
Client-side application programs and server-side remote function
programs that are used with Ninf-G v1 can be used without modification.</p>

<p>However, those programs must be recompiled with
Ninf-G v2 to generate the executable file, etc. so they will
run under Ninf-G v2.</p>

<li>Environment variable names

<p>The names of environment variables have been changed
from NS_DIR to NG_DIR.
Also, in addition to setting the environment variables,
it is necessary to read in the environment settings
file ${NG_DIR}/etc/ninfg-user-env.{sh,csh}.</p>

<p>Note: The environment variable NG_PATH in the setting file
is internally defined and used by Ninf-G system.
Users must not explicitly define and use
the environment variable NG_PATH.</p>

<li>Utility command names

<p>The prefix has been changed from "ns_" to "ng_".
The names of the utility commands are listed below.</p>

<table>
<tr>
<th><b> Ninf-G v1 </b></th>
<th>-</th>
<th><b> Ninf-G v2 </b></th>
</tr>

<tr>
<td> ns_client_gen </td>
<td> -&gt; </td>
<td> ng_cc </td>
</tr>

<tr> 
<td> ns_gen </td>
<td> -&gt; </td>
<td> ng_gen </td>
</tr>

<tr> 
<td> ns_delete_functions </td>
<td> -&gt; </td>
<td> ng_delete_functions </td>
</tr>

<tr> 
<td> ns_dump_functions </td>
<td> -&gt; </td>
<td> ng_dump_functions </td>
</tr>
</table>
</ul>

<h3>
<a name="Assumed_conditions_for_using_Ninf-G">
1.6 Assumed conditions for using Ninf-G</a></h3>

<h3>1.6.1 Prerequisite for installing Ninf-G</h3>

<ul>
<li>All SDK bundles of the Globus Toolkit
(resource, data, and information) must be built from source bundles.</li>

<li>All SDK bundles of the Globus Toolkit
(resource, data, and information) must have a common flavor
by which those bundles are built.
The flavor should be specified as Globus flavor when installing
(configuring) Ninf-G except the flavor is gcc32dbg.
</ul>

<h3>1.6.2 Environment variables for installing / using Ninf-G</h3>

<ul>
<li> GPT_LOCATION must be set to the GPT installation directory.
<li> GLOBUS_LOCATION must be set to the Globus Toolkit installation directory.
<li> Reading the user setting file for use by the Globus Toolkit.
     Read ${GLOBUS_LOCATION}/etc/globus-user-env.{sh,csh}.
<li> NG_DIR must be set to the Ninf-G installation directory.
<li> Reading the user use environment setting file for use by Ninf-G.
     Read ${NG_DIR}/etc/ninfg-user-env.{sh,csh}.
<li> NG_LOG_LEVEL specifies the loglevel that controls the produced
     erorr/warning messages during executions.
     This variable is set to 2 (Error) by sourcing
     ${NG_DIR}/etc/ninfg-user-env.{sh,csh}.
     
</ul>

<h3>1.6.3 Execution Environment</h3>

<ul>
<li> Ninf-G users must be capable of submitting jobs
using the Globus Toolkit from a client machine on which
Ninf-G client program will run to server machines on which
the Globus gatekeeper is running and Ninf-G Executables will be
launched by the Globus jobmanager.

<li> The server machines must be IP-reachable to
the client machine, that is, the server machines should be
capable of establish connection from the server machines to
the client machine.
This implies that the private IP address nodes can be
utilized by Ninf-G if
(1) the Globus gatekeeper is running on a gateway node,
(2) Globus jobmanager such as jobmanager-pbs is available
for launching jobs on backend nodes, and
(3) NAT is available on the gateway node so that backend nodes
can connect to the client machine.
</ul>

<hr>
last update : $Date: 2005/07/08 04:05:07 $

</body>
</html>

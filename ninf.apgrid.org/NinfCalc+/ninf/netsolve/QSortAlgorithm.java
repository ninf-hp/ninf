package ninf.netsolve;/* * @(#)QSortAlgorithm.java	1.6f 95/01/31 James Gosling * * Copyright (c) 1994-1995 Sun Microsystems, Inc. All Rights Reserved. * * Permission to use, copy, modify, and distribute this software * and its documentation for NON-COMMERCIAL or COMMERCIAL purposes and * without fee is hereby granted.  * Please refer to the file http://java.sun.com/copy_trademarks.html * for further important copyright and trademark information and to * http://java.sun.com/licensing.html for further important licensing * information for the Java (tm) Technology. *  * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF * THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR * ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES. *  * THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE * CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE * PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT * NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE * SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE * SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE * PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES").  SUN * SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR * HIGH RISK ACTIVITIES. *//** * A quick sort demonstration algorithm * SortAlgorithm.java, Thu Oct 27 10:32:35 1994 * * @author James Gosling * @version 	1.6f, 31 Jan 1995 * * Modified to sort an array of NetSolve problems by Keith Seymour *  (seymour@cs.utk.edu), 4 Sep 1996. */class QSortAlgorithm {    void sort(Problem a[], int lo0, int hi0) {	int lo = lo0;	int hi = hi0;        String name;	if (lo >= hi) {	    return;	}	Problem mid = a[(lo + hi) / 2];	while (lo < hi) {            name = a[lo].path + a[lo].name;	    while (lo<hi && (name.compareTo(mid.path + mid.name) < 0)) {		lo++;                name = a[lo].path + a[lo].name;	    }            name = new String(a[hi].path + a[hi].name);	    while (lo<hi && (name.compareTo(mid.path + mid.name) > 0)) {		hi--;                name = a[hi].path + a[hi].name;	    }	    if (lo < hi) {		Problem T = a[lo];		a[lo] = a[hi];		a[hi] = T;	    }	}	if (hi < lo) {	    int T = hi;	    hi = lo;	    lo = T;	}	sort(a, lo0, lo);	sort(a, lo == lo0 ? lo+1 : lo, hi0);    }    void sort(Problem a[]) {	sort(a, 0, a.length-1);    }}